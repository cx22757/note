# 0. 标题

**从“无 GC 的语言设计”推导 Rust 的所有权、借用与规则**
 讲者：________  时间：________

------

# 1. 动机：为什么要设计一门“没有 GC 也不需要手动 free”的语言？

- 目标：
  - **确定性性能**：没有 GC 停顿，适合系统编程/实时/嵌入式。
  - **安全内存访问**：在编译期尽量消灭 U.B.（未定义行为）。
  - **零开销抽象**：高层抽象不牺牲底层性能。
- 传统方案的痛点：
  - 手动内存管理（C/C++）：**悬空指针**、**二次释放**、**泄漏**。
  - GC（Java/Go）：**不可预知停顿**、**额外内存占用**、与 C 交互复杂。
- 推导问题：如何在**编译期**就证明内存访问的**时序正确**？

------

# 2. 设计空间对比

| 方案                 | 分配/回收      | 安全性 | 运行时开销 | 典型问题           |
| -------------------- | -------------- | ------ | ---------- | ------------------ |
| 手动（malloc/free）  | 程序员负责     | 低     | 低         | 悬空/二次释放/泄漏 |
| GC                   | 运行时扫描标记 | 高     | 中-高      | 停顿、不可预知     |
| ARC/引用计数         | 引用计数       | 中     | 中         | 循环引用、原子开销 |
| **借用检查（Rust）** | **编译时证明** | **高** | **低**     | 需要学习所有权模型 |

> 推导方向：引入“所有权”与“借用”，让**编译器**为我们证明：对象在被访问时**仍然活着**且**别名规则**成立。

------

# 3. 所有权（Ownership）的核心设想

- 每个值在**任一时刻**，有且仅有**一个所有者**。
- 所有者离开作用域时，**自动析构**（RAII），资源被安全回收。
- 资源转移用**move**语义表达（默认行为）。

> 直觉：把“谁负责 free”这件事，静态地绑定到**作用域**与**所有者**上。

------

# 4. Rust 的所有权三定律（记忆版）

1. **每个值**都有一个所有者（owner）。
2. **同一时刻仅有一个所有者**。
3. 所有者离开作用域，值被**自动 drop**。

- `Copy` 类型（如整数、指针大小的简单值）按位复制；非 `Copy` 类型默认 **move**。
- `Drop` trait 定义析构逻辑（文件句柄、socket、Vec 等）。

------

# 5. Move / Copy / Clone / Drop（快速对比）

- **Move**：转移所有权，旧绑定不可再用（编译器保护）。
- **Copy**：按位复制，旧绑定仍可用（`Copy + Clone` 自动实现、无 `Drop`）。
- **Clone**：显式深拷贝（可能分配）。
- **Drop**：离开作用域自动调用，释放资源。

**示例**：

```rust
let s = String::from("hi");
let t = s;        // move, s 失效
let n = 1u32;     // Copy, n 依旧可用
let u = n;        // 复制一份
```

------

# 6. 为什么需要“借用”（Borrowing）？

- 仅仅转移所有权不够：我们常常需要**暂时访问**一个值，而**不想改变所有权**。
- 引入**引用（reference）**：`&T`（共享借用，读）与 `&mut T`（独占借用，写）。
- 借用期结束后，原所有权不变，引用失效。

------

# 7. 借用的两大类型

- **共享借用 `&T`**：可读，多路别名，不能写。
- **可变借用 `&mut T`**：可写，**独占**（同一时刻只能有一个）。

> 设计原则：**别名 XOR 可变性**（Aliasing XOR Mutability）。

------

# 8. 借用规则（核心）

1. 在同一作用域内：要么**任意多个** `&T`，要么**恰好一个** `&mut T`。
2. 引用必须**始终有效**（不能悬空）。
3. 引用的生命周期必须不超过被引用值的生命周期。

上述借用规则由Rust**借用检查器**执行检查，不符合规则的代码将导致编译错误。

**好处**：编译器据此保证**数据竞争为零**（单线程/多线程都成立）。

------

# 9. 生命周期（Lifetimes）是如何“推导”出来的？

## 场景1

生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据：

```rust
fn main() {
    let r;
    
    {
        let x = 5;
        r = &x;
    }
    
    println!("r: {}", r);
}
```

借用检查器首先通过`r = &x`获悉`r`与`x`相关联，随后比较二者的作用域范围，可以很轻松的判断出`r`活得比`x`久，因此编译报错如下。

```
error[E0597]: `x` does not live long enough
  --> src\main.rs:14:13
   |
13 |         let x = 5;
   |             - binding `x` declared here
14 |         r = &x;
   |             ^^ borrowed value does not live long enough
15 |     }
   |     - `x` dropped here while still borrowed
16 |
17 |     println!("r: {}", r);
   |                       - borrow later used here
```

## 场景2

现在考虑一个新场景，有函数如下：

```rust
fn longgest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

随后这样调用：

```rust
fn main() {
    let s1 = String::from("abcd");
    let result;
    {
        let s2 = String::from("xyz");
        result = longest(s1.as_str(), s2.as_str());
    } // s2 在这里被释放
    println!("result: {}", result);
}
```

我们很容易知道由于s1比s2长，result实际指向的是s1，这段代码从逻辑上讲不会出现悬垂引用。但是编译会报错：

```
1 | fn longgest(x: &str, y: &str) -> &str {
  |                ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
```



- 
- 问题：如何静态证明“引用不悬空”？
- 解：为引用标注**生命周期参数** `'a`，表达“该引用至少活到……”。
- 实际上**大多数时候无需写**，编译器做**生命周期省略**与 **NLL（非词法生命周期）** 推断。

**示意**：

```rust
fn longest<'a>(a: &'a str, b: &'a str) -> &'a str { /* … */ }
```

- 语义：返回值的存活期 **不超过** 两个输入的较小者。

------

# 10. NLL 与借用结束点（减少“活太久”的误判）

- 传统词法：借用到语句块末尾才结束。
- **NLL**：借用在**最后一次使用点**结束，允许更精细的并行借用。

示例：

```rust
let mut s = String::from("abc");
let r = &s;           // 共享借用
println!("{}", r);   // 最后一次使用 r 后，借用立即结束
s.push('x');          // 现在可变借用合法
```

------

# 11. 再借用（Reborrow）

- 从 `&mut T` 派生出一个**更短**的 `&mut T` 或 `&T`，原引用在此期间**冻结**。
- 常用于把 `&mut [u8]` 传给需要**拥有**该引用的对象（如 `Cursor::new(&mut *buf)`）。

------

# 12. 动态大小类型（胖指针）与借用

- `&[T]`、`&str`、`&dyn Trait` 都是**胖指针**：**数据指针 + 元信息**（长度或 vtable）。
- 仍受借用/生命周期规则约束。

------

# 13. 内部可变性：何时打破“别名 XOR 可变”？

- 通过**运行时检查或锁**来延迟保证：
  - 单线程：`Cell<T>` / `RefCell<T>` （借用在运行时检查，可能 `panic`）。
  - 多线程：`Mutex<T>` / `RwLock<T>` （加锁保证互斥/并发读）。
- 典型用途：全局单例可变状态（`OnceLock<Mutex<T>>`）。

------

# 14. 与并发的关系：Send/Sync

- `Send`：类型的所有权可安全在线程间**移动**。
- `Sync`：`&T` 可被多线程**共享**。
- 编译器基于这些自动推断并发安全。

------

# 15. 从“设计目标”到“规则集合”的推导路径回顾

1. 取消 GC，要求**编译期**能证明安全与时序。
2. 引入**所有权**解决“谁负责释放”。
3. 引入**借用**满足“暂时访问不转移所有权”。
4. 以**别名 XOR 可变**、**生命周期**为规则，保证无悬空、无数据竞争。
5. 通过 **NLL/再借用/内部可变性/Send/Sync** 完善工程可用性。

------

# 16. 实战对照：几类典型报错与修复套路

- **已借用为不可变，无法作为可变借用**：缩短不可变借用的活跃期（NLL/作用域/`drop()`）。
- **借用活得不够久**：调整返回值所有权（返回 `String`/`Vec` 而非 `&str`），或提升被借用值的生命周期。
- **同时存在 `&mut` 与 `&`**：利用分片（`split_at_mut`）或重构数据结构。

------

# 17. FFI 场景的所有权与借用边界

- 原则：**谁分配谁释放**；跨边界只传 **裸指针 + 长度/约定**。
- 在 Rust 侧以 `Box<[u8]>`/`Vec<u8>` 管理所有权，并提供 `free_*` 接口。
- 借用不可跨语言边界（生命周期不可表达）。

------

# 18. 代码示例：从“无 GC 设计”落地到 API

```rust
// 借用：读取但不夺走所有权
fn sum(slice: &[i32]) -> i32 { slice.iter().sum() }

// 所有权转移：构造并返回拥有者
fn make_vec(n: usize) -> Vec<u8> { vec![0; n] }

// 可变借用：就地修改
fn fill(buf: &mut [u8], v: u8) { buf.fill(v); }
```

------

# 19. 心智模型与记忆法

- **把所有权当作“使用权 + 释放权”**：谁拿着，谁负责。
- **借用是临时外借**：到期归还，不改变所有者。
- **别名 XOR 可变**：要么多路读，要么单路写。

------

# 20. 练习（可做现场演练）

1. 修复一个“悬空引用”的函数，使其通过编译。
2. 把 `fn process(buf: &mut [u8])` 同时用于 `Vec<u8>` 与 `&mut [u8]`（`AsMut<[u8]>`）。
3. 用 `split_at_mut` 同时写入切片两端，避免可变借用冲突。

------

# 21. 常见陷阱与最佳实践

- 不要返回指向局部临时的引用。
- `into_iter`/`iter_mut` 的所有权差异要分清。
- API 入参尽量用 `impl AsRef<[u8]>`/`impl Into<String>` 提升可用性。

------

# 22. 参考资料

- *The Rust Programming Language*（TRPL）第 4 章：所有权，10 章：生命周期。
- Rust Reference：所有权与借用、生命周期省略规则。
- Rustonomicon：底层不安全与借用规则的由来。

------

# 23. Q & A

（根据听众问题扩展：reborrow、非词法生命周期、Pin、自引用、FFI 等）